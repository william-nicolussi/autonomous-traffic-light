/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * primitives.c
 *
 * Code generation for function 'primitives'
 *
 */

/* Include files */
#include "primitives.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <math.h>

/* Variable Definitions */
static boolean_T isInitialized_primitives = false;

/* Function Declarations */
static double rt_powd_snf(double u0, double u1);

/* Function Definitions */
static double rt_powd_snf(double u0, double u1)
{
  double d;
  double d1;
  double y;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    d = fabs(u0);
    d1 = fabs(u1);
    if (rtIsInf(u1)) {
      if (d == 1.0) {
        y = 1.0;
      } else if (d > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > floor(u1))) {
      y = rtNaN;
    } else {
      y = pow(u0, u1);
    }
  }
  return y;
}

double a_from_coeffs(double t, const double in2[6])
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* A_FROM_COEFFS */
  /*     COEFFS_A_OPT = A_FROM_COEFFS(T,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 15:44:37 */
  return ((in2[1] + in2[2] * t) + in2[3] * (t * t) / 2.0) +
         in2[4] * rt_powd_snf(t, 3.0) / 6.0;
}

double a_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* A_OPT */
  /*     OUT1 = A_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 15:44:37 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return ((a0 - 1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 3.0) *
                    ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                     t4_tmp) *
                    10.0) +
          t * t / (t2 * t2) *
              ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
               b_out1_tmp * 14.0) *
              6.0) -
         1.0 / rt_powd_snf(T, 3.0) * t *
             ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) + b_out1_tmp * 8.0) *
             3.0;
}

void coef_list(double v0, double a0, double sf, double vf, double af, double T,
               double coef_list_var[6])
{
  double b_coef_list_var_tmp;
  double coef_list_var_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* COEF_LIST */
  /*     COEF_LIST_VAR = COEF_LIST(V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 15:44:37 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  coef_list_var[0] = 0.0;
  coef_list_var[1] = v0;
  coef_list_var[2] = a0;
  coef_list_var_tmp = T * v0;
  b_coef_list_var_tmp = T * vf;
  coef_list_var[3] = 1.0 / rt_powd_snf(T, 3.0) *
                     ((((sf * -20.0 + t4) - t3) + coef_list_var_tmp * 12.0) +
                      b_coef_list_var_tmp * 8.0) *
                     -3.0;
  coef_list_var[4] =
      1.0 / (t2 * t2) *
      ((((sf * -30.0 - t3 * 2.0) + t4) + coef_list_var_tmp * 16.0) +
       b_coef_list_var_tmp * 14.0) *
      12.0;
  coef_list_var[5] = 1.0 / rt_powd_snf(T, 5.0) *
                     ((((sf * -12.0 - t3) + coef_list_var_tmp * 6.0) +
                       b_coef_list_var_tmp * 6.0) +
                      t4_tmp) *
                     -60.0;
}

double final_opt_time_pass(double v0, double a0, double sf, double vf)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_TIME_PASS */
  /*     T_VF_SOL = FINAL_OPT_TIME_PASS(V0,A0,SF,VF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 12:57:07 */
  return sf * 30.0 /
         ((v0 * 7.0 + vf * 8.0) -
          sqrt(((a0 * sf * 60.0 + v0 * vf * 112.0) + v0 * v0 * 49.0) +
               vf * vf * 64.0));
}

double final_opt_time_stop(double v0, double a0, double sf)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_TIME_STOP */
  /*     TF_SOL = FINAL_OPT_TIME_STOP(V0,A0,SF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     24-Oct-2025 19:57:27 */
  return sf * 10.0 / (v0 * 2.0 + sqrt(a0 * sf * 5.0 + v0 * v0 * 4.0));
}

double final_opt_vel_pass(double v0, double a0, double sf, double tf)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_VEL_PASS */
  /*     VF_SOL = FINAL_OPT_VEL_PASS(V0,A0,SF,TF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 12:57:01 */
  return ((sf * -15.0 + tf * v0 * 7.0) + a0 * (tf * tf)) * -0.125 / tf;
}

double j_from_coeffs(double t, const double in2[6])
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* J_FROM_COEFFS */
  /*     COEFFS_J_OPT = J_FROM_COEFFS(T,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 15:44:37 */
  return (in2[2] + in2[3] * t) + in2[4] * (t * t) / 2.0;
}

double j_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* J_OPT */
  /*     OUT1 = J_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 15:44:37 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (1.0 / rt_powd_snf(T, 3.0) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) *
              -3.0 -
          1.0 / rt_powd_snf(T, 5.0) * (t * t) *
              ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
               t4_tmp) *
              30.0) +
         t / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) *
             12.0;
}

void primitives_initialize(void)
{
  rt_InitInfAndNaN();
  isInitialized_primitives = true;
}

void primitives_terminate(void)
{
  isInitialized_primitives = false;
}

double s_from_coeffs(double t, const double in2[6])
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* S_FROM_COEFFS */
  /*     COEFFS_S_OPT = S_FROM_COEFFS(T,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 15:44:37 */
  return (((in2[0] * t + in2[1] * (t * t) / 2.0) +
           in2[2] * rt_powd_snf(t, 3.0) / 6.0) +
          in2[3] * rt_powd_snf(t, 4.0) / 24.0) +
         in2[4] * rt_powd_snf(t, 5.0) / 120.0;
}

double s_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* S_OPT */
  /*     OUT1 = S_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 15:44:36 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (((t * v0 + a0 * (t * t) / 2.0) -
           1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 5.0) *
               ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                t4_tmp) /
               2.0) -
          1.0 / rt_powd_snf(T, 3.0) * rt_powd_snf(t, 3.0) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) /
              2.0) +
         rt_powd_snf(t, 4.0) / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) /
             2.0;
}

void student_pass_primitive(double v0, double a0, double sf, double vf_min,
                            double vf_max, double T_min, double T_max,
                            double coeffsT2[6], double *v2, double *T2,
                            double coeffsT1[6], double *v1, double *T1)
{
  double u1;
  double v_star;
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* #codegenvfmin */
  /*  */
  /*            Agent Logic */
  /*          Pass Primitive */
  /*               2025 */
  /*  */
  if (a0 >= 0.0) {
    u1 = final_opt_time_pass(v0, a0, sf, vf_min);
    v_star = final_opt_time_pass(v0, a0, sf, vf_max);
  } else {
    v_star = 0.125 * (7.745966692414834 * sqrt(-a0 * sf) - 7.0 * v0);
    if ((v_star < vf_min) && (vf_min < vf_max)) {
      u1 = final_opt_time_pass(v0, a0, sf, vf_min);
      v_star = final_opt_time_pass(v0, a0, sf, vf_max);
    } else if ((vf_min < v_star) && (v_star < vf_max)) {
      u1 = sqrt(15.0 * sf / -a0);
      v_star = final_opt_time_pass(v0, a0, sf, vf_max);
    } else {
      u1 = 0.0;
      v_star = 0.0;
    }
  }
  /*     [T1, T2] = [T_min, T_max] âˆ© [Tvmax, Tvmin] */
  if ((T_min >= v_star) || rtIsNaN(v_star)) {
    *T1 = T_min;
  } else {
    *T1 = v_star;
  }
  if ((T_max <= u1) || rtIsNaN(u1)) {
    *T2 = T_max;
  } else {
    *T2 = u1;
  }
  if ((*T1 > 0.0) && (*T1 <= *T2)) {
    *v1 = final_opt_vel_pass(v0, a0, sf, *T2);
    *v2 = final_opt_vel_pass(v0, a0, sf, *T1);
    coef_list(v0, a0, sf, *v2, 0.0, *T1, coeffsT1);
    coef_list(v0, a0, sf, *v1, 0.0, *T2, coeffsT2);
  } else {
    *v1 = 0.0;
    *v2 = 0.0;
    for (i = 0; i < 6; i++) {
      coeffsT1[i] = 0.0;
      coeffsT2[i] = 0.0;
    }
  }
}

void student_stop_primitive(double v0, double a0, double sf, double coefs[6],
                            double *maxsf, double *tf)
{
  double d;
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /*  */
  /*           Agent Logic */
  /*          Stop Primitive */
  /*               2025 */
  /*  */
  /*  Function */
  /*  This function must be converted in c code using coder add-on. */
  /*  Copy from this path C:\Program Files\MATLAB\R2024a\extern\include */
  /*  Define the folder to get matlabfunction */
  /*  before typing "coder", execute these lines to add the folder to the */
  /*  project path */
  /*  nameExportFolder = 'functions_exported'; */
  /*  currentFolder = pwd; */
  /*  exportFolder = fullfile(currentFolder, nameExportFolder);
   * %...\matlab\def_functions */
  /*  if ~exist(exportFolder, 'dir') */
  /*      mkdir(exportFolder); */
  /*  end */
  /*  addpath(exportFolder); */
  /*  Stopping Primitive */
  if ((v0 <= 0.0) || (sf == 0.0)) {
    /*  --- Early exits --- */
    *maxsf = 0.0;
    *tf = 0.0;
    for (i = 0; i < 6; i++) {
      coefs[i] = 0.0;
    }
  } else {
    d = 4.0 * (v0 * v0);
    if (d + 5.0 * a0 * sf < 0.0) {
      /*  --- Unfeasible case --- */
      *maxsf = -d / (5.0 * a0);
      *tf = 10.0 * *maxsf / (2.0 * v0);
    } else {
      /*  --- Feasible case --- */
      *maxsf = sf;
      *tf = final_opt_time_stop(v0, a0, sf);
    }
    coef_list(v0, a0, *maxsf, 0.0, 0.0, *tf, coefs);
  }
}

double time_min_vel_pass(double v0, double a0, double sf, double v_min)
{
  (void)v0;
  (void)v_min;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* TIME_MIN_VEL_PASS */
  /*     T_star = TIME_MIN_VEL_PASS(V0,A0,SF,V_MIN) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 12:57:13 */
  return 3.872983346207417 * sqrt(-a0 * sf) / a0;
}

double total_cost_var(double v0, double a0, double sf, double vf, double af,
                      double T)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* TOTAL_COST_VAR */
  /*     TOTAL_COST_VAR = TOTAL_COST_VAR(V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 15:44:38 */
  return 1.0 / rt_powd_snf(T, 5.0) *
         ((((rt_powd_snf(T, 3.0) *
                 (((a0 * v0 * 72.0 + a0 * vf * 48.0) - af * v0 * 48.0) -
                  af * vf * 72.0) +
             T * T *
                 ((((a0 * sf * -120.0 + af * sf * 120.0) + v0 * vf * 336.0) +
                   v0 * v0 * 192.0) +
                  vf * vf * 192.0)) +
            sf * sf * 720.0) +
           rt_powd_snf(T, 4.0) *
               ((a0 * af * -6.0 + a0 * a0 * 9.0) + af * af * 9.0)) -
          T * sf * (v0 + vf) * 720.0);
}

double v_from_coeffs(double t, const double in2[6])
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* V_FROM_COEFFS */
  /*     COEFFS_V_OPT = V_FROM_COEFFS(T,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 15:44:37 */
  return (((in2[0] + in2[1] * t) + in2[2] * (t * t) / 2.0) +
          in2[3] * rt_powd_snf(t, 3.0) / 6.0) +
         in2[4] * rt_powd_snf(t, 4.0) / 24.0;
}

double v_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* V_OPT */
  /*     OUT1 = V_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     13-Nov-2025 15:44:37 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (((v0 + a0 * t) -
           1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 4.0) *
               ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                t4_tmp) *
               2.5) -
          1.0 / rt_powd_snf(T, 3.0) * (t * t) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) *
              1.5) +
         rt_powd_snf(t, 3.0) / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) *
             2.0;
}

/* End of code generation (primitives.c) */
