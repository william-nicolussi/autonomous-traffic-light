/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * primitives.c
 *
 * Code generation for function 'primitives'
 *
 */

/* Include files */
#include "primitives.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <math.h>

/* Variable Definitions */
static boolean_T isInitialized_primitives = false;

/* Function Declarations */
static double rt_powd_snf(double u0, double u1);

/* Function Definitions */
static double rt_powd_snf(double u0, double u1)
{
  double d;
  double d1;
  double y;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    d = fabs(u0);
    d1 = fabs(u1);
    if (rtIsInf(u1)) {
      if (d == 1.0) {
        y = 1.0;
      } else if (d > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > floor(u1))) {
      y = rtNaN;
    } else {
      y = pow(u0, u1);
    }
  }
  return y;
}

double a_from_coeffs(double t, const double in2[6])
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* A_FROM_COEFFS */
  /*     COEFFS_A_OPT = A_FROM_COEFFS(T,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:11 */
  return ((in2[2] + in2[3] * t) + in2[4] * (t * t) / 2.0) +
         in2[5] * rt_powd_snf(t, 3.0) / 6.0;
}

double a_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* A_OPT */
  /*     OUT1 = A_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:11 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return ((a0 - 1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 3.0) *
                    ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                     t4_tmp) *
                    10.0) +
          t * t / (t2 * t2) *
              ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
               b_out1_tmp * 14.0) *
              6.0) -
         1.0 / rt_powd_snf(T, 3.0) * t *
             ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) + b_out1_tmp * 8.0) *
             3.0;
}

void coef_list(double v0, double a0, double sf, double vf, double af, double T,
               double m[6])
{
  double b_m_tmp;
  double m_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* COEF_LIST */
  /*     M = COEF_LIST(V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:11 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  m[0] = 0.0;
  m[1] = v0;
  m[2] = a0;
  m_tmp = T * v0;
  b_m_tmp = T * vf;
  m[3] = 1.0 / rt_powd_snf(T, 3.0) *
         ((((sf * -20.0 + t4) - t3) + m_tmp * 12.0) + b_m_tmp * 8.0) * -3.0;
  m[4] = 1.0 / (t2 * t2) *
         ((((sf * -30.0 - t3 * 2.0) + t4) + m_tmp * 16.0) + b_m_tmp * 14.0) *
         12.0;
  m[5] = 1.0 / rt_powd_snf(T, 5.0) *
         ((((sf * -12.0 - t3) + m_tmp * 6.0) + b_m_tmp * 6.0) + t4_tmp) * -60.0;
}

double final_opt_pos_j0(double v0, double a0, double tf)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_POS_J0 */
  /*     SF_J0_OPT = FINAL_OPT_POS_J0(V0,A0,TF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:59 */
  return tf * (v0 * 4.0 + a0 * tf) * 0.15;
}

void final_opt_time_j0(double v0, double a0, double sf, double tf_j0_opt_all[2])
{
  double t10;
  double t2;
  double t4;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_TIME_J0 */
  /*     TF_J0_OPT_ALL = FINAL_OPT_TIME_J0(V0,A0,SF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:45 */
  t2 = v0 * 5.0;
  t4 = 1.0 / a0;
  t10 = 2.23606797749979 * sqrt(a0 * sf * 8.0 + t2 * v0);
  tf_j0_opt_all[0] = t4 * (t2 + t10) * -0.25;
  tf_j0_opt_all[1] = t4 * (t2 - t10) * -0.25;
}

double final_opt_time_j0_1(double v0, double a0, double sf)
{
  double t2;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_TIME_J0_1 */
  /*     TF_J0_OPT_1 = FINAL_OPT_TIME_J0_1(V0,A0,SF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:45 */
  t2 = v0 * 5.0;
  return (t2 + 2.23606797749979 * sqrt(a0 * sf * 8.0 + t2 * v0)) * -0.25 / a0;
}

double final_opt_time_j0_2(double v0, double a0, double sf)
{
  double t2;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_TIME_J0_2 */
  /*     TF_J0_OPT_2 = FINAL_OPT_TIME_J0_2(V0,A0,SF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:45 */
  t2 = v0 * 5.0;
  return (t2 - 2.23606797749979 * sqrt(a0 * sf * 8.0 + t2 * v0)) * -0.25 / a0;
}

double final_opt_time_pass(double v0, double a0, double sf, double vf)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_TIME_PASS */
  /*     T_VF_SOL = FINAL_OPT_TIME_PASS(V0,A0,SF,VF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:35 */
  return sf * 30.0 /
         ((v0 * 7.0 + vf * 8.0) +
          sqrt(((a0 * sf * 60.0 + v0 * vf * 112.0) + v0 * v0 * 49.0) +
               vf * vf * 64.0));
}

double final_opt_time_stop(double v0, double a0, double sf)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_TIME_STOP */
  /*     TF_SOL = FINAL_OPT_TIME_STOP(V0,A0,SF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:51 */
  return sf * 10.0 / (v0 * 2.0 + sqrt(a0 * sf * 5.0 + v0 * v0 * 4.0));
}

double final_opt_time_stop_j0(double v0, double a0)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_TIME_STOP_J0 */
  /*     Tsf_j0_opt = FINAL_OPT_TIME_STOP_J0(V0,A0) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:59 */
  return v0 * -2.0 / a0;
}

double final_opt_vel_j0(double v0, double a0, double sf, double tf)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_VEL_J0 */
  /*     VF_J0_OPT = FINAL_OPT_VEL_J0(V0,A0,SF,TF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:43 */
  return ((sf * -20.0 + tf * v0 * 12.0) + a0 * (tf * tf) * 3.0) * -0.125 / tf;
}

double final_opt_vel_pass(double v0, double a0, double sf, double tf)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* FINAL_OPT_VEL_PASS */
  /*     VF_SOL = FINAL_OPT_VEL_PASS(V0,A0,SF,TF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:35 */
  return ((sf * -15.0 + tf * v0 * 7.0) + a0 * (tf * tf)) * -0.125 / tf;
}

double j_from_coeffs(double t, const double in2[6])
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* J_FROM_COEFFS */
  /*     COEFFS_J_OPT = J_FROM_COEFFS(T,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:11 */
  return (in2[3] + in2[4] * t) + in2[5] * (t * t) / 2.0;
}

double j_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* J_OPT */
  /*     OUT1 = J_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:11 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (1.0 / rt_powd_snf(T, 3.0) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) *
              -3.0 -
          1.0 / rt_powd_snf(T, 5.0) * (t * t) *
              ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
               t4_tmp) *
              30.0) +
         t / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) *
             12.0;
}

double min_vel(double v0, double a0, double sf)
{
  double t2;
  double v_star_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* MIN_VEL */
  /*     V_STAR = MIN_VEL(V0,A0,SF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:36 */
  t2 = a0 * sf;
  v_star_tmp = sqrt(-t2);
  return 1.0 / v_star_tmp *
         (3.872983346207417 * t2 * 2.0 - v_star_tmp * v0 * 7.0) / 8.0;
}

void pass_primitive(double v0, double a0, double sf, double v_min, double v_max,
                    double T_min, double T_max, double m1[6], double *v1,
                    double *T1, double m2[6], double *v2, double *T2)
{
  double v_star;
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* #codegenvfmin */
  /*  */
  /*            Agent Logic */
  /*          Pass Primitive */
  /*               2025 */
  /*  */
  if (a0 >= 0.0) {
    *T2 = final_opt_time_pass(v0, a0, sf, v_min);
    *T1 = final_opt_time_pass(v0, a0, sf, v_max);
  } else {
    *T2 = time_min_vel_pass(a0, sf);
    v_star = min_vel(v0, a0, sf);
    if ((v_star < v_min) && (v_min <= v_max)) {
      *T2 = final_opt_time_pass(v0, a0, sf, v_min);
      *T1 = final_opt_time_pass(v0, a0, sf, v_max);
    } else if ((v_min < v_star) && (v_star < v_max)) {
      *T1 = final_opt_time_pass(v0, a0, sf, v_max);
    } else {
      *T2 = 0.0;
      *T1 = 0.0;
    }
  }
  /*     [T1, T2] = [T_min, T_max] âˆ© [Tvmax, Tvmin] */
  if ((!(T_min == 0.0)) || (!(T_max == 0.0))) {
    if ((T_min >= *T1) || rtIsNaN(*T1)) {
      *T1 = T_min;
    }
    if ((T_max <= *T2) || rtIsNaN(*T2)) {
      *T2 = T_max;
    }
  }
  if ((*T1 > 0.0) && (*T1 <= *T2)) {
    *v1 = final_opt_vel_pass(v0, a0, sf, *T2);
    *v2 = final_opt_vel_pass(v0, a0, sf, *T1);
    coef_list(v0, a0, sf, *v2, 0.0, *T1, m1);
    coef_list(v0, a0, sf, *v1, 0.0, *T2, m2);
  } else {
    *v1 = 0.0;
    *v2 = 0.0;
    for (i = 0; i < 6; i++) {
      m1[i] = 0.0;
      m2[i] = 0.0;
    }
    *T1 = 0.0;
    *T2 = 0.0;
  }
}

void pass_primitive_j0(double v0, double a0, double sf, double v_min,
                       double v_max, double m[6], double *sf_j0, double *tf_j0)
{
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* vf_min */
  /*           Agent Logic */
  /*          Pass Primitive J0 */
  /*               2025 */
  /*  */
  *tf_j0 = final_opt_time_j0_1(v0, a0, sf);
  *sf_j0 = final_opt_vel_j0(v0, a0, sf, *tf_j0);
  if ((v_min < *sf_j0) && (*sf_j0 < v_max)) {
    /*  (?) */
    coef_list(v0, a0, sf, *sf_j0, 0.0, *tf_j0, m);
  } else {
    *tf_j0 = final_opt_time_j0_2(v0, a0, sf);
    *sf_j0 = final_opt_vel_j0(v0, a0, sf, *tf_j0);
    if ((v_min < *sf_j0) && (*sf_j0 < v_max)) {
      coef_list(v0, a0, sf, *sf_j0, 0.0, *tf_j0, m);
    } else {
      for (i = 0; i < 6; i++) {
        m[i] = 0.0;
      }
      *sf_j0 = 0.0;
      *tf_j0 = 0.0;
    }
  }
}

void primitives_initialize(void)
{
  rt_InitInfAndNaN();
  isInitialized_primitives = true;
}

void primitives_terminate(void)
{
  isInitialized_primitives = false;
}

double s_from_coeffs(double t, const double in2[6])
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* S_FROM_COEFFS */
  /*     COEFFS_S_OPT = S_FROM_COEFFS(T,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:11 */
  return ((((in2[0] + in2[1] * t) + in2[2] * (t * t) / 2.0) +
           in2[3] * rt_powd_snf(t, 3.0) / 6.0) +
          in2[4] * rt_powd_snf(t, 4.0) / 24.0) +
         in2[5] * rt_powd_snf(t, 5.0) / 120.0;
}

double s_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* S_OPT */
  /*     OUT1 = S_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:10 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (((t * v0 + a0 * (t * t) / 2.0) -
           1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 5.0) *
               ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                t4_tmp) /
               2.0) -
          1.0 / rt_powd_snf(T, 3.0) * rt_powd_snf(t, 3.0) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) /
              2.0) +
         rt_powd_snf(t, 4.0) / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) /
             2.0;
}

void stop_primitive(double v0, double a0, double sf, double m[6], double *s_max,
                    double *tf)
{
  double d;
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /*  */
  /*           Agent Logic */
  /*          Stop Primitive */
  /*               2025 */
  /*  */
  /*  Function */
  /*  This function must be converted in c code using coder add-on. */
  /*  Copy from this path C:\Program Files\MATLAB\R2024a\extern\include */
  /*  Define the folder to get matlabfunction */
  /*  before typing "coder", execute these lines to add the folder to the */
  /*  project path */
  /*  nameExportFolder = 'functions_exported'; */
  /*  currentFolder = pwd; */
  /*  exportFolder = fullfile(currentFolder, nameExportFolder);
   * %...\matlab\def_functions */
  /*  if ~exist(exportFolder, 'dir') */
  /*      mkdir(exportFolder); */
  /*  end */
  /*  addpath(exportFolder); */
  /*  Stopping Primitive */
  if ((v0 <= 0.0) || (sf == 0.0)) {
    /*  If negative velocity or null final position, return all 0 */
    *s_max = 0.0;
    *tf = 0.0;
    for (i = 0; i < 6; i++) {
      m[i] = 0.0;
    }
  } else {
    d = 4.0 * (v0 * v0);
    if (d + 5.0 * a0 * sf < 0.0) {
      /*  --- Unfeasible case --- */
      *s_max = -d / (5.0 * a0);
      *tf = 10.0 * *s_max / (2.0 * v0);
    } else {
      /*  --- Feasible case --- */
      *s_max = sf;
      *tf = final_opt_time_stop(v0, a0, sf);
    }
    coef_list(v0, a0, *s_max, 0.0, 0.0, *tf, m);
  }
}

void stop_primitive_j0(double v0, double a0, double m[6], double *sf_j0,
                       double *tf_j0)
{
  int i;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /*  */
  /*            Agent Logic */
  /*          Stop Primitive J0 */
  /*               2025 */
  /*  */
  if ((v0 > 0.0) && (a0 < 0.0)) {
    *tf_j0 = final_opt_time_stop_j0(v0, a0);
    *sf_j0 = final_opt_pos_j0(v0, a0, *tf_j0);
    coef_list(v0, a0, *sf_j0, 0.0, 0.0, *tf_j0, m);
  } else {
    *tf_j0 = 0.0;
    *sf_j0 = 0.0;
    for (i = 0; i < 6; i++) {
      m[i] = 0.0;
    }
  }
}

double time_min_vel_pass(double a0, double sf)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* TIME_MIN_VEL_PASS */
  /*     T_star = TIME_MIN_VEL_PASS(A0,SF) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:36 */
  return 3.872983346207417 * sqrt(-a0 * sf) / a0;
}

double total_cost(double v0, double a0, double sf, double vf, double af,
                  double T)
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* TOTAL_COST */
  /*     J = TOTAL_COST(V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:12 */
  return 1.0 / rt_powd_snf(T, 5.0) *
         ((((rt_powd_snf(T, 3.0) *
                 (((a0 * v0 * 72.0 + a0 * vf * 48.0) - af * v0 * 48.0) -
                  af * vf * 72.0) +
             T * T *
                 ((((a0 * sf * -120.0 + af * sf * 120.0) + v0 * vf * 336.0) +
                   v0 * v0 * 192.0) +
                  vf * vf * 192.0)) +
            sf * sf * 720.0) +
           rt_powd_snf(T, 4.0) *
               ((a0 * af * -6.0 + a0 * a0 * 9.0) + af * af * 9.0)) -
          T * sf * (v0 + vf) * 720.0);
}

double v_from_coeffs(double t, const double in2[6])
{
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* V_FROM_COEFFS */
  /*     COEFFS_V_OPT = V_FROM_COEFFS(T,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:11 */
  return (((in2[1] + in2[2] * t) + in2[3] * (t * t) / 2.0) +
          in2[4] * rt_powd_snf(t, 3.0) / 6.0) +
         in2[5] * rt_powd_snf(t, 4.0) / 24.0;
}

double v_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  if (!isInitialized_primitives) {
    primitives_initialize();
  }
  /* V_OPT */
  /*     OUT1 = V_OPT(t,V0,A0,SF,VF,AF,T) */
  /*     This function was generated by the Symbolic Math Toolbox version 24.1.
   */
  /*     01-Dec-2025 18:09:10 */
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (((v0 + a0 * t) -
           1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 4.0) *
               ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                t4_tmp) *
               2.5) -
          1.0 / rt_powd_snf(T, 3.0) * (t * t) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) *
              1.5) +
         rt_powd_snf(t, 3.0) / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) *
             2.0;
}

/* End of code generation (primitives.c) */
